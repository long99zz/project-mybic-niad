package handlers

import (
	"backend/models"
	"context"
	"log"
	"net/http"
	"sort"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// GetMyInvoicesMongo - Lấy danh sách hóa đơn của user hiện tại
func GetMyInvoicesMongo(db *mongo.Database) gin.HandlerFunc {
	return func(c *gin.Context) {
		invoiceCollection := db.Collection("invoices")
		travelCollection := db.Collection("travel_insurance_invoices")
		homeCollection := db.Collection("home_insurance_invoices")
		productCollection := db.Collection("products")
		ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel()

		userIDStr, exists := c.Get("user_id")
		if !exists {
			c.JSON(401, gin.H{"error": "Bạn chưa đăng nhập!"})
			return
		}

		userIDVal := userIDStr.(string)
		var userID interface{} = userIDVal
		if intVal, err := strconv.Atoi(userIDVal); err == nil {
			userID = intVal
		} else if objID, err := primitive.ObjectIDFromHex(userIDVal); err == nil {
			userID = objID
		}

		type MyInvoiceView struct {
			InvoiceID       interface{} `json:"invoice_id"`
			InvoiceType     string      `json:"invoice_type"`
			ProductID       interface{} `json:"product_id"`
			ProductName     *string     `json:"product_name"`
			Status          string      `json:"status"`
			CreatedAt       *string     `json:"created_at"`
			InsuranceStart  *string     `json:"insurance_start"`
			InsuranceEnd    *string     `json:"insurance_end"`
			InsuranceAmount *float64    `json:"insurance_amount"`
			DepartureDate   *string     `json:"departure_date"`
			ReturnDate      *string     `json:"return_date"`
			UpdatedAt       *string     `json:"updated_at"`
		}

		// Helper function to format time to YYYY-MM-DD
		formatDate := func(t time.Time) *string {
			if t.IsZero() {
				return nil
			}
			formatted := t.Format("2006-01-02")
			return &formatted
		}

		var result []MyInvoiceView

		// 1. Lấy hóa đơn chung (invoices)
		opts := options.Find().SetSort(bson.M{"created_at": -1})
		cursor, err := invoiceCollection.Find(ctx, bson.M{"user_id": userID}, opts)
		if err == nil {
			defer cursor.Close(ctx)
			var invoices []bson.M
			if err := cursor.All(ctx, &invoices); err == nil {
				for _, inv := range invoices {
					// Extract fields from bson.M
					prodID := inv["product_id"]
					status, _ := inv["status"].(string)
					
					// Get created_at - MongoDB stores as primitive.DateTime (milliseconds)
					createdAt := time.Time{}
					if ca, ok := inv["created_at"].(primitive.DateTime); ok {
						createdAt = ca.Time()
						log.Printf("[GetMyInvoicesMongo] Section 1 - createdAt: %v", createdAt)
					} else if ca, ok := inv["created_at"].(time.Time); ok {
						createdAt = ca
					} else {
						log.Printf("[GetMyInvoicesMongo] Section 1 - createdAt type: %T, value: %v", inv["created_at"], inv["created_at"])
					}
					
					updatedAt := time.Time{}
					if ua, ok := inv["updated_at"].(primitive.DateTime); ok {
						updatedAt = ua.Time()
					} else if ua, ok := inv["updated_at"].(time.Time); ok {
						updatedAt = ua
					}
					
					var insStart, insEnd *string
					if is, ok := inv["insurance_start"].(primitive.DateTime); ok {
						insStart = formatDate(is.Time())
					} else if is, ok := inv["insurance_start"].(time.Time); ok && !is.IsZero() {
						insStart = formatDate(is)
					}
					
					if ie, ok := inv["insurance_end"].(primitive.DateTime); ok {
						insEnd = formatDate(ie.Time())
					} else if ie, ok := inv["insurance_end"].(time.Time); ok && !ie.IsZero() {
						insEnd = formatDate(ie)
					}
					
					var insAmount *float64
					if ia, ok := inv["insurance_amount"].(float64); ok {
						insAmount = &ia
					}

					// Get product name from products collection using product_id
					var productName *string
					if prodID != nil {
						// Try direct query first
						var productBson bson.M
						if err := productCollection.FindOne(ctx, bson.M{"_id": prodID}).Decode(&productBson); err == nil {
							if pn, ok := productBson["name"].(string); ok && pn != "" {
								productName = &pn
							}
						}
					}

					createdAtStr := formatDate(createdAt)
					log.Printf("[GetMyInvoicesMongo] Section 1 - formatted createdAt: %v", createdAtStr)

					result = append(result, MyInvoiceView{
						InvoiceID:       inv["_id"],
						InvoiceType:     "Chung",
						ProductID:       prodID,
						ProductName:     productName,
						Status:          status,
						CreatedAt:       createdAtStr,
						InsuranceStart:  insStart,
						InsuranceEnd:    insEnd,
						InsuranceAmount: insAmount,
						DepartureDate:   nil,
						ReturnDate:      nil,
						UpdatedAt:       formatDate(updatedAt),
					})
				}
			}
		}

		// 2. Lấy hóa đơn du lịch
		cursor, err = travelCollection.Find(ctx, bson.M{"user_id": userID}, opts)
		if err == nil {
			defer cursor.Close(ctx)
			var travelInvoices []models.TravelInsuranceInvoice
			if err := cursor.All(ctx, &travelInvoices); err == nil {
				for _, inv := range travelInvoices {
					var productName *string
					if inv.ProductID != nil {
						var product models.Product
						if err := productCollection.FindOne(ctx, bson.M{"_id": inv.ProductID}).Decode(&product); err == nil {
							productName = &product.Name
						}
					}

					result = append(result, MyInvoiceView{
						InvoiceID:       inv.ID,
						InvoiceType:     "Du lịch",
						ProductID:       inv.ProductID,
						ProductName:     productName,
						Status:          inv.Status,
						CreatedAt:       formatDate(inv.CreatedAt),
						InsuranceStart:  formatDate(inv.DepartureDate),
						InsuranceEnd:    formatDate(inv.ReturnDate),
						InsuranceAmount: &inv.TotalAmount,
						DepartureDate:   formatDate(inv.DepartureDate),
						ReturnDate:      formatDate(inv.ReturnDate),
						UpdatedAt:       formatDate(inv.UpdatedAt),
					})
				}
			}
		}

		// 3. Lấy hóa đơn nhà
		cursor, err = homeCollection.Find(ctx, bson.M{"user_id": userID}, opts)
		if err == nil {
			defer cursor.Close(ctx)
			var homeInvoices []models.HomeInsuranceInvoice
			if err := cursor.All(ctx, &homeInvoices); err == nil {
				for _, inv := range homeInvoices {
					var productName *string
					if !inv.ProductID.IsZero() {
						var product models.Product
						if err := productCollection.FindOne(ctx, bson.M{"_id": inv.ProductID}).Decode(&product); err == nil {
							productName = &product.Name
						}
					}

					totalAmount := inv.HomeInsuranceAmount + inv.AssetInsuranceAmount
					if inv.TotalAmount > 0 {
						totalAmount = inv.TotalAmount
					}

					result = append(result, MyInvoiceView{
						InvoiceID:       inv.ID,
						InvoiceType:     "Nhà",
						ProductID:       &inv.ProductID,
						ProductName:     productName,
						Status:          inv.Status,
						CreatedAt:       formatDate(inv.CreatedAt),
						InsuranceStart:  formatDate(inv.InsuranceStart),
						InsuranceEnd:    formatDate(inv.InsuranceEnd),
						InsuranceAmount: &totalAmount,
						DepartureDate:   nil,
						ReturnDate:      nil,
						UpdatedAt:       formatDate(inv.UpdatedAt),
					})
				}
			}
		}

		// Sắp xếp tất cả hóa đơn theo created_at giảm dần
		sort.Slice(result, func(i, j int) bool {
			// Parse string dates back to time.Time for comparison
			if result[i].CreatedAt == nil || result[j].CreatedAt == nil {
				return result[i].CreatedAt != nil // nil dates go last
			}
			ti, _ := time.Parse("2006-01-02", *result[i].CreatedAt)
			tj, _ := time.Parse("2006-01-02", *result[j].CreatedAt)
			return ti.After(tj)
		})

		c.JSON(200, result)
	}
}

// GetInvoiceDetailUserMongo - Lấy chi tiết hóa đơn của user
func GetInvoiceDetailUserMongo(db *mongo.Database) gin.HandlerFunc {
	return func(c *gin.Context) {
		invoiceCollection := db.Collection("invoices")
		travelCollection := db.Collection("travel_insurance_invoices")
		homeCollection := db.Collection("home_insurance_invoices")
		productCollection := db.Collection("products")
		customerCollection := db.Collection("customer_registration")
		participantCollection := db.Collection("participants")
		travelParticipantCollection := db.Collection("travel_participants")
		ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel()

		invoiceIDStr := c.Param("id")
		invoiceID, err := primitive.ObjectIDFromHex(invoiceIDStr)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "ID hóa đơn không hợp lệ!"})
			return
		}

		type InvoiceDetail struct {
			InvoiceID       primitive.ObjectID `json:"invoice_id"`
			InvoiceType     string             `json:"invoice_type"`
			ProductName     string             `json:"product_name"`
			Status          string             `json:"status"`
			CreatedAt       time.Time          `json:"created_at"`
			InsuranceStart  *time.Time         `json:"insurance_start"`
			InsuranceEnd    *time.Time         `json:"insurance_end"`
			InsuranceAmount *float64           `json:"insurance_amount"`
			Customer        interface{}        `json:"customer"`
			Participants    interface{}        `json:"participants"`
		}

		var detail InvoiceDetail
		var found bool

		// Try common invoices first
		var invoice models.Invoice
		err = invoiceCollection.FindOne(ctx, bson.M{"_id": invoiceID}).Decode(&invoice)
		if err == nil {
			found = true
			detail.InvoiceID = invoice.ID
			detail.InvoiceType = "Chung"
			detail.Status = invoice.Status
			detail.CreatedAt = invoice.CreatedAt
			detail.InsuranceStart = &invoice.InsuranceStart
			detail.InsuranceEnd = &invoice.InsuranceEnd
			detail.InsuranceAmount = &invoice.InsuranceAmount

			// Get product name
			if invoice.ProductID.IsZero() == false {
				var product models.Product
				if err := productCollection.FindOne(ctx, bson.M{"_id": invoice.ProductID}).Decode(&product); err == nil {
					detail.ProductName = product.Name
				}
			}

			// Get customer info
			if invoice.CustomerID != nil {
				var customer models.CustomerRegistration
				if err := customerCollection.FindOne(ctx, bson.M{"_id": invoice.CustomerID}).Decode(&customer); err == nil {
					detail.Customer = gin.H{
						"customer_id": customer.ID.Hex(),
						"full_name":   customer.FullName,
						"email":       customer.Email,
						"phone":       customer.PhoneNumber,
					}
				}
			}

			// Get participants
			participantCursor, err := participantCollection.Find(ctx, bson.M{"invoice_id": invoiceID})
			if err == nil {
				var participants []models.Participant
				if err := participantCursor.All(ctx, &participants); err == nil {
					detail.Participants = participants
				}
				participantCursor.Close(ctx)
			}
		}

		// Try travel invoices
		if !found {
			var travelInvoice models.TravelInsuranceInvoice
			err = travelCollection.FindOne(ctx, bson.M{"_id": invoiceID}).Decode(&travelInvoice)
			if err == nil {
				found = true
				detail.InvoiceID = travelInvoice.ID
				detail.InvoiceType = "Du lịch"
				detail.Status = travelInvoice.Status
				detail.CreatedAt = travelInvoice.CreatedAt
				detail.InsuranceStart = &travelInvoice.DepartureDate
				detail.InsuranceEnd = &travelInvoice.ReturnDate
				detail.InsuranceAmount = &travelInvoice.TotalAmount

				// Get product name
				if travelInvoice.ProductID != nil {
					var product models.Product
					if err := productCollection.FindOne(ctx, bson.M{"_id": travelInvoice.ProductID}).Decode(&product); err == nil {
						detail.ProductName = product.Name
					}
				}

				// Get customer info
				if travelInvoice.CustomerID != nil {
					var customer models.CustomerRegistration
					if err := customerCollection.FindOne(ctx, bson.M{"_id": travelInvoice.CustomerID}).Decode(&customer); err == nil {
						detail.Customer = gin.H{
							"customer_id": customer.ID.Hex(),
							"full_name":   customer.FullName,
							"email":       customer.Email,
							"phone":       customer.PhoneNumber,
						}
					}
				}

				// Get travel participants
				participantCursor, err := travelParticipantCollection.Find(ctx, bson.M{"invoice_id": invoiceID})
				if err == nil {
					var participants []models.TravelParticipant
					if err := participantCursor.All(ctx, &participants); err == nil {
						detail.Participants = participants
					}
					participantCursor.Close(ctx)
				}
			}
		}

		// Try home invoices
		if !found {
			var homeInvoice models.HomeInsuranceInvoice
			err = homeCollection.FindOne(ctx, bson.M{"_id": invoiceID}).Decode(&homeInvoice)
			if err == nil {
				found = true
				detail.InvoiceID = homeInvoice.ID
				detail.InvoiceType = "Nhà"
				detail.Status = homeInvoice.Status
				detail.CreatedAt = homeInvoice.CreatedAt
				detail.InsuranceStart = &homeInvoice.InsuranceStart
				detail.InsuranceEnd = &homeInvoice.InsuranceEnd

				totalAmount := homeInvoice.HomeInsuranceAmount + homeInvoice.AssetInsuranceAmount
				if homeInvoice.TotalAmount > 0 {
					totalAmount = homeInvoice.TotalAmount
				}
				detail.InsuranceAmount = &totalAmount

				// Get product name
				if homeInvoice.ProductID.IsZero() == false {
					var product models.Product
					if err := productCollection.FindOne(ctx, bson.M{"_id": homeInvoice.ProductID}).Decode(&product); err == nil {
						detail.ProductName = product.Name
					}
				}

					cartItems = append(cartItems, CartItem{
						InvoiceID:   inv["_id"],
						InvoiceType: "Chung",
						ProductID:   prodID,
						ProductName: productName,
						Status:      status,
						Amount:      amount,
						CreatedAt:   formatDate(createdAt),
					})
				}
			}
		}

		// 2. Get unpaid travel invoices
		cursor, err = travelCollection.Find(ctx, bson.M{
			"user_id": userID,
			"status":  bson.M{"$in": []string{"Chưa thanh toán", "Pending"}},
		}, opts)
		if err == nil {
			defer cursor.Close(ctx)
			var travelInvoices []models.TravelInsuranceInvoice
			if err := cursor.All(ctx, &travelInvoices); err == nil {
				for _, inv := range travelInvoices {
					var productName *string
					if inv.ProductID != nil {
						var product bson.M
						if err := productCollection.FindOne(ctx, bson.M{"_id": inv.ProductID}).Decode(&product); err == nil {
							if pn, ok := product["name"].(string); ok && pn != "" {
								productName = &pn
							} else if pn, ok := product["product_name"].(string); ok && pn != "" {
								productName = &pn
							}
						}
					}

					cartItems = append(cartItems, CartItem{
						InvoiceID:   inv.ID,
						InvoiceType: "Du lịch",
						ProductID:   inv.ProductID,
						ProductName: productName,
						Status:      inv.Status,
						Amount:      inv.TotalAmount,
						CreatedAt:   formatDate(inv.CreatedAt),
					})
				}
			}
		}

		// 3. Get unpaid home invoices
		cursor, err = homeCollection.Find(ctx, bson.M{
			"user_id": userID,
			"status":  bson.M{"$in": []string{"Chưa thanh toán", "Pending"}},
		}, opts)
		if err == nil {
			defer cursor.Close(ctx)
			var homeInvoices []models.HomeInsuranceInvoice
			if err := cursor.All(ctx, &homeInvoices); err == nil {
				for _, inv := range homeInvoices {
					var productName *string
					if !inv.ProductID.IsZero() {
						var product bson.M
						if err := productCollection.FindOne(ctx, bson.M{"_id": inv.ProductID}).Decode(&product); err == nil {
							if pn, ok := product["name"].(string); ok && pn != "" {
								productName = &pn
							} else if pn, ok := product["product_name"].(string); ok && pn != "" {
								productName = &pn
							}
						}
					}

					totalAmount := inv.HomeInsuranceAmount + inv.AssetInsuranceAmount
					if inv.TotalAmount > 0 {
						totalAmount = inv.TotalAmount
					}

					cartItems = append(cartItems, CartItem{
						InvoiceID:   inv.ID,
						InvoiceType: "Nhà",
						ProductID:   &inv.ProductID,
						ProductName: productName,
						Status:      inv.Status,
						Amount:      totalAmount,
						CreatedAt:   formatDate(inv.CreatedAt),
					})
				}
			}
		}

		// Sort by CreatedAt descending - parse string dates back to time.Time
		sort.Slice(cartItems, func(i, j int) bool {
			if cartItems[i].CreatedAt == nil || cartItems[j].CreatedAt == nil {
				return cartItems[i].CreatedAt != nil
			}
			ti, _ := time.Parse("2006-01-02", *cartItems[i].CreatedAt)
			tj, _ := time.Parse("2006-01-02", *cartItems[j].CreatedAt)
			return ti.After(tj)
		})

		c.JSON(http.StatusOK, gin.H{
			"data":  cartItems,
			"total": len(cartItems),
		})
	}
}

// DeleteCartInvoiceMongo - Xóa đơn hàng khỏi giỏ
func DeleteCartInvoiceMongo(db *mongo.Database) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		userIDStr, exists := c.Get("user_id")
		if !exists {
			c.JSON(401, gin.H{"error": "Bạn chưa đăng nhập!"})
			return
		}

		userIDVal := userIDStr.(string)

		// Build flexible user_id query (could be int, string, or ObjectID)
		var userID interface{} = userIDVal
		if intVal, err := strconv.Atoi(userIDVal); err == nil {
			userID = intVal
		} else if objID, err := primitive.ObjectIDFromHex(userIDVal); err == nil {
			userID = objID
		}

		invoiceIDStr := c.Param("invoice_id")

		// Try to parse invoice_id as different types
		var invoiceID interface{} = invoiceIDStr
		if intVal, err := strconv.Atoi(invoiceIDStr); err == nil {
			invoiceID = intVal
		} else if objID, err := primitive.ObjectIDFromHex(invoiceIDStr); err == nil {
			invoiceID = objID
		}

		// Try deleting from each potential invoice collection (invoices, travel, home)
		collections := []string{"invoices", "travel_insurance_invoices", "home_insurance_invoices"}
		var deleteErr error
		var deleted bool

		for _, collName := range collections {
			coll := db.Collection(collName)
			res, err := coll.DeleteOne(ctx, bson.M{"_id": invoiceID, "user_id": userID})
			if err != nil {
				// record error but continue trying other collections
				deleteErr = err
				continue
			}
			if res.DeletedCount > 0 {
				deleted = true
				break
			}
		}

		if deleteErr != nil && !deleted {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Lỗi xóa hóa đơn!"})
			return
		}

		if !deleted {
			c.JSON(http.StatusNotFound, gin.H{"error": "Hóa đơn không tồn tại hoặc không thuộc về bạn!"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Xóa hóa đơn thành công!"})
	}
}
